from typing import Any, Optional, Union, Dict, List, Callable, Type, TypeVar, Generic, Sequence
from typing_extensions import ParamSpec

_T = TypeVar('_T')
_M = TypeVar('_M', bound='Model')

# Base Model class
class Model:
    pk: Any
    id: Any
    
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def save(self, force_insert: bool = ..., force_update: bool = ..., using: Optional[str] = ..., update_fields: Optional[Sequence[str]] = ...) -> None: ...
    def delete(self, using: Optional[str] = ..., keep_parents: bool = ...) -> tuple: ...
    def refresh_from_db(self, using: Optional[str] = ..., fields: Optional[Sequence[str]] = ...) -> None: ...
    def clean(self) -> None: ...
    def clean_fields(self, exclude: Optional[Sequence[str]] = ...) -> None: ...
    def full_clean(self, exclude: Optional[Sequence[str]] = ..., validate_unique: bool = ...) -> None: ...
    def validate_unique(self, exclude: Optional[Sequence[str]] = ...) -> None: ...
    
    @classmethod
    def from_db(cls: Type[_M], db: Optional[str], field_names: Sequence[str], values: Sequence[Any]) -> _M: ...

# QuerySet
class QuerySet(Generic[_M]):
    def __init__(self, model: Optional[Type[_M]] = ..., query: Optional[Any] = ..., using: Optional[str] = ..., hints: Optional[Dict[str, Any]] = ...) -> None: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __getitem__(self, k: Union[int, slice]) -> Union[_M, 'QuerySet[_M]']: ...
    
    def filter(self, *args: Any, **kwargs: Any) -> 'QuerySet[_M]': ...
    def exclude(self, *args: Any, **kwargs: Any) -> 'QuerySet[_M]': ...
    def annotate(self, *args: Any, **kwargs: Any) -> 'QuerySet[_M]': ...
    def order_by(self, *field_names: str) -> 'QuerySet[_M]': ...
    def reverse(self) -> 'QuerySet[_M]': ...
    def distinct(self, *field_names: str) -> 'QuerySet[_M]': ...
    def values(self, *fields: str) -> 'QuerySet[Any]': ...
    def values_list(self, *fields: str, flat: bool = ..., named: bool = ...) -> 'QuerySet[Any]': ...
    def select_related(self, *fields: Optional[str]) -> 'QuerySet[_M]': ...
    def prefetch_related(self, *lookups: Any) -> 'QuerySet[_M]': ...
    def extra(self, select: Optional[Dict[str, str]] = ..., where: Optional[List[str]] = ..., params: Optional[List[Any]] = ..., tables: Optional[List[str]] = ..., order_by: Optional[Sequence[str]] = ..., select_params: Optional[Sequence[Any]] = ...) -> 'QuerySet[_M]': ...
    def defer(self, *fields: str) -> 'QuerySet[_M]': ...
    def only(self, *fields: str) -> 'QuerySet[_M]': ...
    def using(self, alias: str) -> 'QuerySet[_M]': ...
    def select_for_update(self, nowait: bool = ..., skip_locked: bool = ..., of: Sequence[str] = ..., no_key: bool = ...) -> 'QuerySet[_M]': ...
    
    def get(self, *args: Any, **kwargs: Any) -> _M: ...
    def create(self, **kwargs: Any) -> _M: ...
    def get_or_create(self, defaults: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> tuple: ...
    def update_or_create(self, defaults: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> tuple: ...
    def bulk_create(self, objs: Sequence[_M], batch_size: Optional[int] = ..., ignore_conflicts: bool = ..., update_conflicts: bool = ..., update_fields: Optional[Sequence[str]] = ..., unique_fields: Optional[Sequence[str]] = ...) -> List[_M]: ...
    def bulk_update(self, objs: Sequence[_M], fields: Sequence[str], batch_size: Optional[int] = ...) -> int: ...
    def count(self) -> int: ...
    def in_bulk(self, id_list: Optional[Sequence[Any]] = ..., *, field_name: str = ...) -> Dict[Any, _M]: ...
    def iterator(self, chunk_size: int = ...) -> Any: ...
    def latest(self, *fields: str) -> _M: ...
    def earliest(self, *fields: str) -> _M: ...
    def first(self) -> Optional[_M]: ...
    def last(self) -> Optional[_M]: ...
    def aggregate(self, *args: Any, **kwargs: Any) -> Dict[str, Any]: ...
    def exists(self) -> bool: ...
    def update(self, **kwargs: Any) -> int: ...
    def delete(self) -> tuple: ...
    def none(self) -> 'QuerySet[_M]': ...
    def all(self) -> 'QuerySet[_M]': ...
    def union(self, *other_qs: 'QuerySet[_M]', all: bool = ...) -> 'QuerySet[_M]': ...
    def intersection(self, *other_qs: 'QuerySet[_M]') -> 'QuerySet[_M]': ...
    def difference(self, *other_qs: 'QuerySet[_M]') -> 'QuerySet[_M]': ...

# Manager
class Manager(Generic[_M]):
    def __init__(self) -> None: ...
    def get_queryset(self) -> QuerySet[_M]: ...
    
    # Delegate to QuerySet
    def all(self) -> QuerySet[_M]: ...
    def filter(self, *args: Any, **kwargs: Any) -> QuerySet[_M]: ...
    def exclude(self, *args: Any, **kwargs: Any) -> QuerySet[_M]: ...
    def get(self, *args: Any, **kwargs: Any) -> _M: ...
    def create(self, **kwargs: Any) -> _M: ...
    def get_or_create(self, defaults: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> tuple: ...
    def update_or_create(self, defaults: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> tuple: ...
    def count(self) -> int: ...
    def exists(self) -> bool: ...

# Aggregation functions
class Avg:
    def __init__(self, expression: Any, output_field: Optional[Any] = ..., distinct: bool = ..., filter: Optional[Any] = ..., **extra: Any) -> None: ...

class Count:
    def __init__(self, expression: Any, distinct: bool = ..., filter: Optional[Any] = ..., **extra: Any) -> None: ...

class Max:
    def __init__(self, expression: Any, output_field: Optional[Any] = ..., filter: Optional[Any] = ..., **extra: Any) -> None: ...

class Min:
    def __init__(self, expression: Any, output_field: Optional[Any] = ..., filter: Optional[Any] = ..., **extra: Any) -> None: ...

class Sum:
    def __init__(self, expression: Any, output_field: Optional[Any] = ..., distinct: bool = ..., filter: Optional[Any] = ..., **extra: Any) -> None: ...

# Q objects for complex queries
class Q:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __or__(self, other: 'Q') -> 'Q': ...
    def __and__(self, other: 'Q') -> 'Q': ...
    def __invert__(self) -> 'Q': ...

# Prefetch objects
class Prefetch:
    def __init__(self, lookup: str, queryset: Optional[QuerySet] = ..., to_attr: Optional[str] = ...) -> None: ...

__all__ = [
    "Model",
    "QuerySet", 
    "Manager",
    "Q",
    "Prefetch",
    "Avg",
    "Count",
    "Max",
    "Min", 
    "Sum"
]