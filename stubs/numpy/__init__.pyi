from typing import Any, Union, Tuple, List, Optional, Sequence, Iterator, overload
from typing_extensions import Literal
import sys

# Core types
_Shape = Tuple[int, ...]
_DType = Any
_ArrayLike = Union["ndarray", Sequence[Any], Any]

# NumPy array class
class ndarray:
    def __init__(self, shape: _Shape, dtype: _DType = ..., buffer: Any = ..., offset: int = ..., strides: Optional[_Shape] = ..., order: Optional[str] = ...) -> None: ...
    
    # Attributes
    shape: _Shape
    size: int
    ndim: int
    dtype: _DType
    data: Any
    itemsize: int
    nbytes: int
    T: "ndarray"
    
    # Methods
    def reshape(self, *shape: int, order: str = ...) -> "ndarray": ...
    def flatten(self, order: str = ...) -> "ndarray": ...
    def ravel(self, order: str = ...) -> "ndarray": ...
    def transpose(self, *axes: int) -> "ndarray": ...
    def swapaxes(self, axis1: int, axis2: int) -> "ndarray": ...
    def copy(self, order: str = ...) -> "ndarray": ...
    def astype(self, dtype: _DType, order: str = ..., casting: str = ..., subok: bool = ..., copy: bool = ...) -> "ndarray": ...
    
    # Array operations
    def sum(self, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., keepdims: bool = ...) -> Union["ndarray", Any]: ...
    def mean(self, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., keepdims: bool = ...) -> Union["ndarray", Any]: ...
    def std(self, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., keepdims: bool = ..., ddof: int = ...) -> Union["ndarray", Any]: ...
    def var(self, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., keepdims: bool = ..., ddof: int = ...) -> Union["ndarray", Any]: ...
    def min(self, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> Union["ndarray", Any]: ...
    def max(self, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> Union["ndarray", Any]: ...
    def argmin(self, axis: Optional[int] = ..., keepdims: bool = ...) -> Union["ndarray", int]: ...
    def argmax(self, axis: Optional[int] = ..., keepdims: bool = ...) -> Union["ndarray", int]: ...
    
    # Indexing
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    
    # Math operations
    def __add__(self, other: Any) -> "ndarray": ...
    def __sub__(self, other: Any) -> "ndarray": ...
    def __mul__(self, other: Any) -> "ndarray": ...
    def __truediv__(self, other: Any) -> "ndarray": ...
    def __floordiv__(self, other: Any) -> "ndarray": ...
    def __mod__(self, other: Any) -> "ndarray": ...
    def __pow__(self, other: Any) -> "ndarray": ...
    def __matmul__(self, other: Any) -> "ndarray": ...
    
    # Comparison operations
    def __eq__(self, other: Any) -> Any: ...  # type: ignore[override]
    def __ne__(self, other: Any) -> Any: ...  # type: ignore[override]
    def __lt__(self, other: Any) -> "ndarray": ...
    def __le__(self, other: Any) -> "ndarray": ...
    def __gt__(self, other: Any) -> "ndarray": ...
    def __ge__(self, other: Any) -> "ndarray": ...

# Data types
float32: _DType
float64: _DType
int32: _DType
int64: _DType
uint8: _DType
uint16: _DType
uint32: _DType
uint64: _DType
bool_: _DType
complex64: _DType
complex128: _DType

# Array creation functions
def array(object: _ArrayLike, dtype: Optional[_DType] = ..., copy: bool = ..., order: Optional[str] = ..., subok: bool = ..., ndmin: int = ...) -> ndarray: ...
def zeros(shape: Union[int, _Shape], dtype: _DType = ..., order: str = ...) -> ndarray: ...
def ones(shape: Union[int, _Shape], dtype: _DType = ..., order: str = ...) -> ndarray: ...
def empty(shape: Union[int, _Shape], dtype: _DType = ..., order: str = ...) -> ndarray: ...
def full(shape: Union[int, _Shape], fill_value: Any, dtype: Optional[_DType] = ..., order: str = ...) -> ndarray: ...
def eye(N: int, M: Optional[int] = ..., k: int = ..., dtype: _DType = ..., order: str = ...) -> ndarray: ...
def identity(n: int, dtype: Optional[_DType] = ...) -> ndarray: ...

def zeros_like(a: _ArrayLike, dtype: Optional[_DType] = ..., order: str = ..., subok: bool = ..., shape: Optional[_Shape] = ...) -> ndarray: ...
def ones_like(a: _ArrayLike, dtype: Optional[_DType] = ..., order: str = ..., subok: bool = ..., shape: Optional[_Shape] = ...) -> ndarray: ...
def empty_like(a: _ArrayLike, dtype: Optional[_DType] = ..., order: str = ..., subok: bool = ..., shape: Optional[_Shape] = ...) -> ndarray: ...
def full_like(a: _ArrayLike, fill_value: Any, dtype: Optional[_DType] = ..., order: str = ..., subok: bool = ..., shape: Optional[_Shape] = ...) -> ndarray: ...

# Array manipulation
def reshape(a: _ArrayLike, newshape: Union[int, _Shape], order: str = ...) -> ndarray: ...
def concatenate(arrays: Sequence[_ArrayLike], axis: Optional[int] = ..., out: Optional[ndarray] = ..., dtype: Optional[_DType] = ..., casting: str = ...) -> ndarray: ...
def stack(arrays: Sequence[_ArrayLike], axis: int = ..., out: Optional[ndarray] = ..., dtype: Optional[_DType] = ..., casting: str = ...) -> ndarray: ...
def split(ary: _ArrayLike, indices_or_sections: Union[int, Sequence[int]], axis: int = ...) -> List[ndarray]: ...

# Mathematical functions
def add(x1: _ArrayLike, x2: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...
def subtract(x1: _ArrayLike, x2: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...
def multiply(x1: _ArrayLike, x2: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...
def divide(x1: _ArrayLike, x2: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...
def power(x1: _ArrayLike, x2: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...

def sum(a: _ArrayLike, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., out: Optional[ndarray] = ..., keepdims: bool = ..., initial: Any = ..., where: Any = ...) -> Any: ...
def mean(a: _ArrayLike, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., out: Optional[ndarray] = ..., keepdims: bool = ..., where: Any = ...) -> Any: ...
def std(a: _ArrayLike, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., out: Optional[ndarray] = ..., ddof: int = ..., keepdims: bool = ..., where: Any = ...) -> Any: ...
def var(a: _ArrayLike, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[_DType] = ..., out: Optional[ndarray] = ..., ddof: int = ..., keepdims: bool = ..., where: Any = ...) -> Any: ...

def min(a: _ArrayLike, axis: Optional[Union[int, Tuple[int, ...]]] = ..., out: Optional[ndarray] = ..., keepdims: bool = ..., initial: Any = ..., where: Any = ...) -> Any: ...
def max(a: _ArrayLike, axis: Optional[Union[int, Tuple[int, ...]]] = ..., out: Optional[ndarray] = ..., keepdims: bool = ..., initial: Any = ..., where: Any = ...) -> Any: ...
def argmin(a: _ArrayLike, axis: Optional[int] = ..., out: Optional[ndarray] = ..., keepdims: bool = ...) -> Union[ndarray, int]: ...
def argmax(a: _ArrayLike, axis: Optional[int] = ..., out: Optional[ndarray] = ..., keepdims: bool = ...) -> Union[ndarray, int]: ...

# Trigonometric functions
def sin(x: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...
def cos(x: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...
def tan(x: _ArrayLike, out: Optional[ndarray] = ..., **kwargs: Any) -> ndarray: ...

# Linear algebra
def dot(a: _ArrayLike, b: _ArrayLike, out: Optional[ndarray] = ...) -> ndarray: ...
def matmul(x1: _ArrayLike, x2: _ArrayLike, out: Optional[ndarray] = ..., casting: str = ..., order: str = ..., dtype: Optional[_DType] = ..., subok: bool = ..., signature: Any = ..., extobj: Any = ...) -> ndarray: ...

# Constants
pi: float
e: float
inf: float
nan: float

# Random module
class random:
    @staticmethod
    def rand(*dn: int) -> ndarray: ...
    @staticmethod
    def randn(*dn: int) -> ndarray: ...
    @staticmethod
    def randint(low: int, high: Optional[int] = ..., size: Optional[Union[int, _Shape]] = ..., dtype: _DType = ...) -> Union[int, ndarray]: ...
    @staticmethod
    def random(size: Optional[Union[int, _Shape]] = ...) -> Union[float, ndarray]: ...
    @staticmethod
    def choice(a: Union[int, _ArrayLike], size: Optional[Union[int, _Shape]] = ..., replace: bool = ..., p: Optional[_ArrayLike] = ...) -> Union[Any, ndarray]: ...
    @staticmethod
    def seed(seed: Optional[int] = ...) -> None: ...

__all__ = [
    "ndarray",
    "array",
    "zeros",
    "ones", 
    "empty",
    "full",
    "eye",
    "identity",
    "zeros_like",
    "ones_like",
    "empty_like",
    "full_like",
    "reshape",
    "concatenate",
    "stack",
    "split",
    "add",
    "subtract",
    "multiply",
    "divide",
    "power",
    "sum",
    "mean",
    "std",
    "var",
    "min",
    "max",
    "argmin",
    "argmax",
    "sin",
    "cos",
    "tan",
    "dot",
    "matmul",
    "pi",
    "e",
    "inf",
    "nan",
    "random",
    "float32",
    "float64",
    "int32",
    "int64",
    "uint8",
    "uint16", 
    "uint32",
    "uint64",
    "bool_",
    "complex64",
    "complex128"
]